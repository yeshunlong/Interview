# Java和C++区别

* Java源码会先经过一次编译，成为中间码，中间码再被解释器解释成机器码。对于Java而言，中间码就是字节码(.class)，而解释器在JVM中内置了。
* C++源码一次编译，直接在编译的过程中链接了，形成了机器码。
* C++比Java执行速度快，但是Java可以利用JVM跨平台。
* Java是纯面向对象的语言，所有代码（包括函数、变量）都必须在类中定义。而C++中还有面向过程的东西，比如是全局变量和全局函数。
* C++中有指针，Java中没有，但是有引用。
* C++支持多继承，Java中类都是单继承的。但是继承都有传递性，同时Java中的接口是多继承，类对接口的实现也是多实现。
* C++中，开发需要自己去管理内存，但是Java中JVM有自己的GC机制，虽然有自己的GC机制，但是也会出现OOM和内存泄漏的问题。C++中有析构函数，Java中Object的finalize方法。
* C++运算符可以重载，但是Java中不可以。同时C++中支持强制自动转型，Java中不行，会出现ClassCastException（类型不匹配）。

# const关键字作用

* 修饰变量，说明该变量不可以被改变。
* 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）。
* 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改。
* 修饰成员函数，说明该成员函数内不能修改成员变量。

# static关键字作用

* 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
* 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
* 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
* 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

# this 指针

* `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
* 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
* 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
* `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。
* `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
* 在以下场景中，经常需要显式引用 `this` 指针：
  * 为实现对象的链式引用。
  * 为避免对同一对象进行赋值操作。
  * 在实现一些数据结构时，如 `list`。

# inline 内联函数特征

* 相当于把内联函数里面的内容写在调用内联函数处。
* 相当于不用执行进入函数的步骤，直接执行函数体。
* 相当于宏，却比宏多了类型检查，真正具有函数特性。
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数。
* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

# 编译器对 inline 函数的处理步骤

* 将 inline 函数体复制到 inline 函数调用点处。
* 为所用 inline 函数中的局部变量分配内存空间。
* 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中。
* 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

# inline 内联函数优缺点

优点

* 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
* 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
* 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
* 内联函数在运行时可调试，而宏定义不可以。

缺点

* 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
* inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
* 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

# 虚函数（virtual）可以是内联函数（inline）吗？

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
* 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

# volatile

```cpp
volatile int i = 10; 
```

* volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
* volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）。
* const 可以是 volatile （如只读的状态寄存器）。
* 指针可以是 volatile。

# sizeof()对指针和数组的不同结果

* sizeof 对数组，得到整个数组所占空间大小。
* sizeof 对指针，得到指针本身所占空间大小。

# #pragma pack(n)用处

设定结构体、联合以及类成员变量以 n 字节方式对齐

# 位域

```cpp
Bit mode: 2;    // mode 占 2 位
```

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

* 位域在内存中的布局是与机器有关的。
* 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定。
* 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域。

# extern "C"

* 被 `extern` 限定的函数或变量是 extern 类型的。
* 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的。

`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

# C++ 中 struct 和 class

总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

* 最本质的一个区别就是默认的访问控制

  * 默认的继承访问权限。struct 是 public 的，class 是 private 的。
  * struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

# explicit（显式）关键字

* explicit 修饰构造函数时，可以防止隐式转换和复制初始化。
* explicit 修饰转换函数时，可以防止隐式转换，但 **按语境转换** 除外。

# friend 友元类和友元函数

* 能访问私有成员
* 破坏封装性
* 友元关系不可传递
* 友元关系的单向性
* 友元声明的形式及数量不受限制

# 左值引用和右值引用

左值引用：常规引用，一般表示对象的身份。

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
* 能够更简洁明确地定义泛型函数。

# 虚继承、虚函数

虚函数用于实现动态多态，也就是在程序的运行阶段动态地选择合适的成员函数。

虚继承用于解决多继承条件下的菱形继承（两个子类继承同一个父类而又有子类同时继承这两个子类）问题（浪费存储空间、存在二义性）。

* 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
* 不同之处：
  * 虚继承
    * 虚基类依旧存在继承类中，占用存储空间
    * 虚基类表存储的是虚基类相对直接继承类的偏移
  * 虚函数
    * 虚函数不占用存储空间
    * 虚函数表存储的是虚函数地址

# 抽象类、接口类、聚合类

* 抽象类：含有纯虚函数的类
* 接口类：仅含有纯虚函数的抽象类
* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：

  * 所有成员都是 public
  * 没有定义任何构造函数
  * 没有类内初始化
  * 没有基类，也没有 virtual 函数

# 内存分配和管理

C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete。

malloc/free 和 new/delete配对使用，避免内存泄漏和多重释放。它们之间联系与区别如下：

* new：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
* delete：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
* new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

# delete this 合法吗？

合法，但：

* 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
* 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
* 必须保证成员函数的 `delete this ` 后面没有调用 this 了
* 必须保证 `delete this` 后没有人使用了

# 智能指针

* shared_ptr

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

* weak_ptr

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

* unique_ptr

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

# 强制类型转换运算符

* static_cast

  * 用于非多态类型的转换
  * 不执行运行时类型检查（转换安全性不如 dynamic_cast）
  * 通常用于转换数值数据类型（如 float -> int）
  * 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）
* dynamic_cast

  * 用于多态类型的转换
  * 执行行运行时类型检查
  * 只适用于指针或引用
  * 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
  * 可以在整个类层次结构中移动指针，包括向上转换、向下转换
* const_cast

  * 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）
* reinterpret_cast

  * 用于位的简单重新解释
  * 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一
  * 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）
  * 也允许将任何整数类型转换为任何指针类型以及反向转换
  * reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性
  * reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引

# 运行时类型信息 (RTTI)

RTTI（Runtime Type Identification）是“运行时类型识别”的意思。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。

C++通过以下两个关键字提供RTTI功能。

* typeid：该运算符返回其表达式或类型名的实际类型
* dynamic_cast：该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用（也就是所谓的下行转换）
